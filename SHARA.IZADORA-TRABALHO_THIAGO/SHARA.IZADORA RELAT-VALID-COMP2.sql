-- ==================================================
--   ======== FUNÇÕES DE CÁLCULO DE TOTAIS ============
-- ==================================================

CREATE OR REPLACE FUNCTION CALCULAR_TOTAL_PEDIDO()
RETURNS TRIGGER AS $$
DECLARE
    V_TOTAL DECIMAL(10,2);
BEGIN
  
    SELECT SUM(QUANT * VALOR_UNITARIO)
    INTO V_TOTAL
    FROM ITEM_PEDIDO
    WHERE ID_PEDIDO = COALESCE(NEW.ID_PEDIDO, OLD.ID_PEDIDO); 


    UPDATE PEDIDO
    SET TOTAL = COALESCE(V_TOTAL, 0)
    WHERE ID_PEDIDO = COALESCE(NEW.ID_PEDIDO, OLD.ID_PEDIDO);

    RETURN NEW;
END;
$$ LANGUAGE PLPGSQL;

CREATE TRIGGER TRG_CALCULAR_TOTAL_PEDIDO
AFTER INSERT OR UPDATE OR DELETE ON ITEM_PEDIDO
FOR EACH ROW
EXECUTE FUNCTION CALCULAR_TOTAL_PEDIDO();


-- --------------------------------------------------

CREATE OR REPLACE FUNCTION CALCULAR_TOTAL_COMPRA()
RETURNS TRIGGER AS $$
DECLARE
    V_TOTAL DECIMAL(10,2);
BEGIN
    
    SELECT SUM(QUANT * VALOR_UNITARIO)
    INTO V_TOTAL
    FROM ITEM_COMPRA
    WHERE ID_COMPRA = COALESCE(NEW.ID_COMPRA, OLD.ID_COMPRA);  

    UPDATE COMPRA
    SET TOTAL = COALESCE(V_TOTAL, 0)
    WHERE ID_COMPRA = COALESCE(NEW.ID_COMPRA, OLD.ID_COMPRA); 

    RETURN NEW;
END;
$$ LANGUAGE PLPGSQL;

CREATE TRIGGER TRG_CALCULAR_TOTAL_COMPRA
AFTER INSERT OR UPDATE OR DELETE ON ITEM_COMPRA
FOR EACH ROW
EXECUTE FUNCTION CALCULAR_TOTAL_COMPRA();

-- ==================================================
--   =========== FUNÇÕES DE VALIDAÇÃO ================
-- ==================================================

CREATE OR REPLACE FUNCTION DEFINIR_VALOR_UNITARIO()
RETURNS TRIGGER AS $$
BEGIN
    SELECT PRECO INTO NEW.VALOR_UNITARIO
    FROM PRODUTO
    WHERE ID_PRODUTO = NEW.ID_PRODUTO;
    
    RETURN NEW;
END;
$$ LANGUAGE PLPGSQL;

CREATE TRIGGER TRG_DEFINIR_VALOR_UNITARIO
BEFORE INSERT ON ITEM_PEDIDO
FOR EACH ROW
EXECUTE FUNCTION DEFINIR_VALOR_UNITARIO();

-- --------------------------------------------------

CREATE OR REPLACE FUNCTION VALIDAR_EMAIL(EMAIL_PARAM VARCHAR)
RETURNS BOOLEAN AS $$
BEGIN
    RETURN EMAIL_PARAM ~* '^[A-Z0-9._%-]+@[A-Z0-9.-]+\.[A-Z]+$';
END;
$$ LANGUAGE PLPGSQL;

-- --------------------------------------------------

CREATE OR REPLACE FUNCTION VALIDAR_TELEFONE(TELEFONE_PARAM VARCHAR)
RETURNS BOOLEAN AS $$
BEGIN
    RETURN TELEFONE_PARAM ~ '^[0-9]{10,11}$';
END;
$$ LANGUAGE PLPGSQL;

-- --------------------------------------------------

CREATE OR REPLACE FUNCTION VALIDA_EMAIL_CLIENTE()
RETURNS TRIGGER AS $$
BEGIN
    IF NOT VALIDAR_EMAIL(NEW.EMAIL) THEN
        RAISE EXCEPTION 'EMAIL INVÁLIDO: %', NEW.EMAIL;
    END IF;
    RETURN NEW;
END;
$$ LANGUAGE PLPGSQL;

CREATE TRIGGER TRG_EMAIL_CLIENTE
BEFORE INSERT OR UPDATE ON CLIENTE
FOR EACH ROW
EXECUTE FUNCTION VALIDA_EMAIL_CLIENTE();

-- --------------------------------------------------

CREATE OR REPLACE FUNCTION VALIDA_TELEFONE_FUNCIONARIO()
RETURNS TRIGGER AS $$
BEGIN
    IF NOT VALIDAR_TELEFONE(NEW.TELEFONE) THEN
        RAISE EXCEPTION 'TELEFONE INVÁLIDO: %', NEW.TELEFONE;
    END IF;
    RETURN NEW;
END;
$$ LANGUAGE PLPGSQL;

CREATE TRIGGER TRG_TELEFONE_FUNCIONARIO
BEFORE INSERT OR UPDATE ON FUNCIONARIO
FOR EACH ROW
EXECUTE FUNCTION VALIDA_TELEFONE_FUNCIONARIO();

-- ==================================================
-- =========== FUNÇÕES DE COMPOSIÇÃO DE PRODUTOS =======
-- ==================================================
CREATE OR REPLACE FUNCTION ADICIONAR_COMPOSICAO_PRODUTO(
    PROD1 INT,
    PROD2 INT,
    QUANTIDADE INT
) RETURNS TEXT AS $$
BEGIN
    IF NOT EXISTS (SELECT 1 FROM PRODUTO WHERE ID_PRODUTO = PROD1) THEN
        RETURN 'ERRO: PRODUTO PRINCIPAL NÃO ENCONTRADO.';
    END IF;
    
    IF NOT EXISTS (SELECT 1 FROM PRODUTO WHERE ID_PRODUTO = PROD2) THEN
        RETURN 'ERRO: PRODUTO COMPONENTE NÃO ENCONTRADO.';
    END IF;
    
    INSERT INTO COMPOSICAO_PRONTA(ID_PROD_COMP1, ID_PROD_COMP2, QUANT)
    VALUES (PROD1, PROD2, QUANTIDADE);
    
    RETURN 'SUCESSO: COMPOSIÇÃO REGISTRADA.';
    
EXCEPTION
    WHEN INSUFFICIENT_PRIVILEGE THEN
        RETURN 'ERRO: SEU PERFIL NÃO TEM PERMISSÃO PARA CRIAR COMPOSIÇÕES.';
    WHEN OTHERS THEN
        RAISE EXCEPTION 'ERRO AO CRIAR COMPOSIÇÃO (% + %): %', PROD1, PROD2, SQLERRM;
        RETURN 'ERRO: FALHA AO REGISTRAR COMPOSIÇÃO.';
END;
$$ LANGUAGE PLPGSQL;

-- --------------------------------------------------
CREATE OR REPLACE FUNCTION VERIFICAR_ESTOQUE_COMPOSICAO_RECURSIVO(
    P_ID_PRODUTO INT,
    P_QUANTIDADE NUMERIC,
    P_VISITADOS INT[] DEFAULT '{}'
) RETURNS BOOLEAN AS $$
DECLARE
    COMPONENTE RECORD;
    TEM_ESTOQUE BOOLEAN;
    COMPONENTE_EH_COMPOSTO BOOLEAN;
    QUANT_AJUSTADA NUMERIC;
BEGIN
    BEGIN
        IF P_ID_PRODUTO = ANY(P_VISITADOS) THEN
            RETURN FALSE;
        END IF;

        IF NOT EXISTS (
            SELECT 1 FROM COMPOSICAO_PRONTA WHERE ID_PROD_COMP1 = P_ID_PRODUTO
        ) THEN
            RETURN (
                SELECT ESTOQUE >= P_QUANTIDADE
                FROM PRODUTO
                WHERE ID_PRODUTO = P_ID_PRODUTO
            );
        END IF;

        FOR COMPONENTE IN
            SELECT CP.ID_PROD_COMP2, CP.QUANT, COALESCE(CP.PERDA, 0) AS PERDA
            FROM COMPOSICAO_PRONTA CP
            WHERE CP.ID_PROD_COMP1 = P_ID_PRODUTO
        LOOP
            QUANT_AJUSTADA := CEIL(
                COMPONENTE.QUANT::NUMERIC * P_QUANTIDADE * (1 + COMPONENTE.PERDA::NUMERIC / 100)
            );

            SELECT EXISTS (
                SELECT 1 FROM COMPOSICAO_PRONTA
                WHERE ID_PROD_COMP1 = COMPONENTE.ID_PROD_COMP2
            ) INTO COMPONENTE_EH_COMPOSTO;

            IF COMPONENTE_EH_COMPOSTO THEN
                TEM_ESTOQUE := VERIFICAR_ESTOQUE_COMPOSICAO_RECURSIVO(
                    COMPONENTE.ID_PROD_COMP2,
                    QUANT_AJUSTADA,
                    P_VISITADOS || P_ID_PRODUTO
                );
            ELSE
                TEM_ESTOQUE := (
                    SELECT ESTOQUE >= QUANT_AJUSTADA
                    FROM PRODUTO
                    WHERE ID_PRODUTO = COMPONENTE.ID_PROD_COMP2
                );
            END IF;

            IF NOT TEM_ESTOQUE THEN
                RETURN FALSE;
            END IF;
        END LOOP;

        RETURN TRUE;

    EXCEPTION
        WHEN OTHERS THEN
            RAISE NOTICE 'Erro na verificação de estoque para o produto %: %', P_ID_PRODUTO, SQLERRM;
            RETURN FALSE;
    END;
END;
$$ LANGUAGE PLPGSQL;

-- --------------------------------------------------
CREATE OR REPLACE FUNCTION MONTAR_PRODUTO_COMPOSTO(
    P_ID_PRODUTO INT,
    P_QUANTIDADE INT
) RETURNS TEXT AS $$
DECLARE
    COMPONENTE RECORD;
    CUSTO_TOTAL DECIMAL(10,2) := 0;
    PRECO_SUGERIDO DECIMAL(10,2);
    MARGEM DECIMAL(5,2) := 1.3;
BEGIN
    IF NOT VERIFICAR_ESTOQUE_COMPOSICAO_RECURSIVO(P_ID_PRODUTO, P_QUANTIDADE) THEN
        RETURN 'ERRO: ESTOQUE INSUFICIENTE PARA MONTAGEM.';
    END IF;

    FOR COMPONENTE IN
        SELECT 
            CP.ID_PROD_COMP2, 
            CP.QUANT * P_QUANTIDADE AS QUANT_NECESSARIA,
            CP.PERDA, 
            P.PRECO, 
            P.ESTOQUE
        FROM COMPOSICAO_PRONTA CP
        JOIN PRODUTO P ON CP.ID_PROD_COMP2 = P.ID_PRODUTO
        WHERE CP.ID_PROD_COMP1 = P_ID_PRODUTO
    LOOP
        COMPONENTE.QUANT_NECESSARIA := CEIL(COMPONENTE.QUANT_NECESSARIA * (1 + COMPONENTE.PERDA / 100));

        UPDATE PRODUTO
        SET ESTOQUE = ESTOQUE - COMPONENTE.QUANT_NECESSARIA
        WHERE ID_PRODUTO = COMPONENTE.ID_PROD_COMP2;

        CUSTO_TOTAL := CUSTO_TOTAL + (COMPONENTE.QUANT_NECESSARIA * COMPONENTE.PRECO);
    END LOOP;

    UPDATE PRODUTO
    SET ESTOQUE = ESTOQUE + P_QUANTIDADE
    WHERE ID_PRODUTO = P_ID_PRODUTO;

    PRECO_SUGERIDO := (CUSTO_TOTAL / P_QUANTIDADE) * MARGEM;

    UPDATE PRODUTO
    SET PRECO = PRECO_SUGERIDO
    WHERE ID_PRODUTO = P_ID_PRODUTO;

    RETURN 'SUCESSO: PRODUTO MONTADO. PREÇO SUGERIDO: R$ ' || TO_CHAR(PRECO_SUGERIDO, 'FM99999990.00');

EXCEPTION
    WHEN INSUFFICIENT_PRIVILEGE THEN
        RETURN 'ERRO: SEU PERFIL NÃO TEM PERMISSÃO PARA MONTAR PRODUTOS.';
    WHEN OTHERS THEN
        RAISE EXCEPTION 'ERRO AO MONTAR PRODUTO (ID: %): %', P_ID_PRODUTO, SQLERRM;
        RETURN 'ERRO: FALHA NA MONTAGEM DO PRODUTO.';
END;
$$ LANGUAGE PLPGSQL;

-- --------------------------------------------------
CREATE OR REPLACE FUNCTION PROCESSAR_PEDIDO_COMPOSTO()
RETURNS TRIGGER AS $$
DECLARE
    TEMPO_MONTAGEM INT := 0;
    EH_PRODUTO_COMPOSTO BOOLEAN;
    RESULTADO TEXT;
BEGIN
    SELECT EXISTS (
        SELECT 1 FROM COMPOSICAO_PRONTA
        WHERE ID_PROD_COMP1 = NEW.ID_PRODUTO
    ) INTO EH_PRODUTO_COMPOSTO;

    IF EH_PRODUTO_COMPOSTO THEN
        SELECT COALESCE(SUM(CP.TEMPO_MONTAGEM), 0) INTO TEMPO_MONTAGEM
        FROM COMPOSICAO_PRONTA CP
        WHERE CP.ID_PROD_COMP1 = NEW.ID_PRODUTO;

        IF POSITION('NECESSITA MONTAGEM' IN COALESCE((SELECT OBSERVACAO FROM PEDIDO WHERE ID_PEDIDO = NEW.ID_PEDIDO), '')) = 0 THEN
            UPDATE PEDIDO
            SET OBSERVACAO = COALESCE(OBSERVACAO, '') || ' | NECESSITA MONTAGEM - TEMPO ESTIMADO: ' || TEMPO_MONTAGEM || ' MIN'
            WHERE ID_PEDIDO = NEW.ID_PEDIDO;
        END IF;

        -- Tenta montar diretamente
        RESULTADO := MONTAR_PRODUTO_COMPOSTO(NEW.ID_PRODUTO, NEW.QUANT);

        -- Mensagem para log/depuração
        RAISE NOTICE '%', RESULTADO;
    END IF;

    RETURN NEW;
END;
$$ LANGUAGE PLPGSQL;

CREATE TRIGGER TRG_PROCESSAR_PEDIDO_COMPOSTO
AFTER INSERT ON ITEM_PEDIDO
FOR EACH ROW
EXECUTE FUNCTION PROCESSAR_PEDIDO_COMPOSTO();

-- ==================================================
-- ================ FUNÇÕES DE RELATÓRIOS ===========
-- ==================================================

CREATE OR REPLACE FUNCTION PRODUTOS_BAIXO_ESTOQUE(LIMITE INT)
RETURNS TABLE(ID_PRODUTO INT, NOME VARCHAR, ESTOQUE INT, PRECO DECIMAL) AS $$
BEGIN
    BEGIN
        RETURN QUERY
        SELECT P.ID_PRODUTO, P.NOME, P.ESTOQUE, P.PRECO
        FROM PRODUTO P
        WHERE P.ESTOQUE < LIMITE AND P.ATIVO = TRUE
        ORDER BY P.ESTOQUE;
        
    EXCEPTION
        WHEN INSUFFICIENT_PRIVILEGE THEN
            RAISE EXCEPTION 'ACESSO NEGADO: CONSULTA DE ESTOQUE';
        WHEN OTHERS THEN
            RAISE EXCEPTION 'ERRO AO CONSULTAR ESTOQUE: %', SQLERRM;
    END;
END;
$$ LANGUAGE PLPGSQL;


-- --------------------------------------------------

CREATE OR REPLACE FUNCTION PRODUTOS_MAIS_VENDIDOS(LIMITE INT)
RETURNS TABLE(ID_PRODUTO INT, NOME VARCHAR, QUANTIDADE BIGINT, TOTAL DECIMAL) AS $$
BEGIN
    BEGIN
        RETURN QUERY
        SELECT P.ID_PRODUTO, P.NOME, SUM(IP.QUANT), SUM(IP.QUANT * IP.VALOR_UNITARIO)
        FROM PRODUTO P
        JOIN ITEM_PEDIDO IP ON P.ID_PRODUTO = IP.ID_PRODUTO
        JOIN PEDIDO PE ON IP.ID_PEDIDO = PE.ID_PEDIDO
        WHERE P.ATIVO = TRUE AND IP.ATIVO = TRUE AND PE.ATIVO = TRUE
        GROUP BY P.ID_PRODUTO, P.NOME
        ORDER BY SUM(IP.QUANT) DESC
        LIMIT LIMITE;
        
    EXCEPTION
        WHEN INSUFFICIENT_PRIVILEGE THEN
            RAISE EXCEPTION 'ACESSO NEGADO: RELATÓRIO DE VENDAS';
        WHEN OTHERS THEN
            RAISE EXCEPTION 'ERRO AO GERAR RELATÓRIO: %', SQLERRM;
    END;
END;
$$ LANGUAGE PLPGSQL;

-- --------------------------------------------------

CREATE OR REPLACE FUNCTION VENDAS_POR_FUNCIONARIO()
RETURNS TABLE(
    ID_FUNCIONARIO INT,
    NOME VARCHAR,
    CARGO VARCHAR,
    TOTAL_VENDAS DECIMAL,
    QTD_PEDIDOS BIGINT
) AS $$
BEGIN
    BEGIN
        RETURN QUERY
        SELECT F.ID_FUNCIONARIO, F.NOME, F.CARGO,
               COALESCE(SUM(P.TOTAL), 0)::DECIMAL AS TOTAL_VENDAS,
               COUNT(P.ID_PEDIDO)::BIGINT AS QTD_PEDIDOS
        FROM FUNCIONARIO F
        LEFT JOIN PEDIDO P ON F.ID_FUNCIONARIO = P.ID_FUNCIONARIO
        WHERE F.ATIVO = TRUE AND (P.ID_PEDIDO IS NULL OR P.ATIVO = TRUE)
        GROUP BY F.ID_FUNCIONARIO, F.NOME, F.CARGO
        ORDER BY TOTAL_VENDAS DESC;
        
    EXCEPTION
        WHEN INSUFFICIENT_PRIVILEGE THEN
            RAISE EXCEPTION 'ACESSO NEGADO: RELATÓRIO DE VENDAS POR FUNCIONÁRIO';
        WHEN OTHERS THEN
            RAISE EXCEPTION 'ERRO AO GERAR RELATÓRIO: %', SQLERRM;
    END;
END;
$$ LANGUAGE PLPGSQL;

-- ==================================================
-- ==================================================
-- ==================================================
