-- ==================================================
--   ======== FUNÇÕES DE CÁLCULO DE TOTAIS ==========
-- ==================================================

CREATE OR REPLACE FUNCTION CALCULAR_TOTAL_PEDIDO()
RETURNS TRIGGER AS $$
DECLARE
    V_TOTAL DECIMAL(10,2);
    V_ID_PEDIDO INT;
BEGIN
    V_ID_PEDIDO := COALESCE(NEW.ID_PEDIDO, OLD.ID_PEDIDO);

    SELECT SUM(QUANT * VALOR_UNITARIO)
    INTO V_TOTAL
    FROM ITEM_PEDIDO
    WHERE ID_PEDIDO = V_ID_PEDIDO;

    UPDATE PEDIDO
    SET TOTAL = COALESCE(V_TOTAL, 0)
    WHERE ID_PEDIDO = V_ID_PEDIDO;

    RETURN NEW;
END;
$$ LANGUAGE PLPGSQL;

CREATE OR REPLACE TRIGGER TRG_CALCULAR_TOTAL_PEDIDO
AFTER INSERT OR UPDATE OR DELETE ON ITEM_PEDIDO
FOR EACH ROW
EXECUTE FUNCTION CALCULAR_TOTAL_PEDIDO();

-- --------------------------------------------------

CREATE OR REPLACE FUNCTION CALCULAR_TOTAL_COMPRA()
RETURNS TRIGGER AS $$
DECLARE
    V_TOTAL DECIMAL(10,2);
    V_ID_COMPRA INT;
BEGIN
    V_ID_COMPRA := COALESCE(NEW.ID_COMPRA, OLD.ID_COMPRA);

    SELECT SUM(QUANT * VALOR_UNITARIO)
    INTO V_TOTAL
    FROM ITEM_COMPRA
    WHERE ID_COMPRA = V_ID_COMPRA;

    UPDATE COMPRA
    SET TOTAL = COALESCE(V_TOTAL, 0)
    WHERE ID_COMPRA = V_ID_COMPRA;

    RETURN NEW;
END;
$$ LANGUAGE PLPGSQL;

CREATE OR REPLACE TRIGGER TRG_CALCULAR_TOTAL_COMPRA
AFTER INSERT OR UPDATE OR DELETE ON ITEM_COMPRA
FOR EACH ROW
EXECUTE FUNCTION CALCULAR_TOTAL_COMPRA();

-- ==================================================
--   =========== FUNÇÕES DE VALIDAÇÃO ===============
-- ==================================================

CREATE OR REPLACE FUNCTION DEFINIR_VALOR_UNITARIO()
RETURNS TRIGGER AS $$
BEGIN
    SELECT PRECO INTO NEW.VALOR_UNITARIO
    FROM PRODUTO
    WHERE ID_PRODUTO = NEW.ID_PRODUTO;

    RETURN NEW;
END;
$$ LANGUAGE PLPGSQL;

CREATE OR REPLACE TRIGGER TRG_DEFINIR_VALOR_UNITARIO
BEFORE INSERT ON ITEM_PEDIDO
FOR EACH ROW
EXECUTE FUNCTION DEFINIR_VALOR_UNITARIO();

-- --------------------------------------------------

CREATE OR REPLACE FUNCTION VALIDAR_EMAIL(EMAIL_PARAM VARCHAR)
RETURNS BOOLEAN AS $$
BEGIN
    RETURN EMAIL_PARAM ~* '^[a-zA-Z0-9._%-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$';
END;
$$ LANGUAGE PLPGSQL;

-- --------------------------------------------------

CREATE OR REPLACE FUNCTION VALIDAR_TELEFONE(TELEFONE_PARAM VARCHAR)
RETURNS BOOLEAN AS $$
BEGIN
    RETURN TELEFONE_PARAM ~ '^[0-9]{10,11}$';
END;
$$ LANGUAGE PLPGSQL;

-- --------------------------------------------------

CREATE OR REPLACE FUNCTION VALIDA_EMAIL_CLIENTE()
RETURNS TRIGGER AS $$
BEGIN
    IF NOT VALIDAR_EMAIL(NEW.EMAIL) THEN
        RAISE EXCEPTION 'EMAIL INVÁLIDO: %', NEW.EMAIL;
    END IF;
    RETURN NEW;
END;
$$ LANGUAGE PLPGSQL;

CREATE OR REPLACE TRIGGER TRG_EMAIL_CLIENTE
BEFORE INSERT OR UPDATE ON CLIENTE
FOR EACH ROW
EXECUTE FUNCTION VALIDA_EMAIL_CLIENTE();

-- --------------------------------------------------

CREATE OR REPLACE FUNCTION VALIDA_TELEFONE_FUNCIONARIO()
RETURNS TRIGGER AS $$
BEGIN
    IF NOT VALIDAR_TELEFONE(NEW.TELEFONE) THEN
        RAISE EXCEPTION 'TELEFONE INVÁLIDO: %', NEW.TELEFONE;
    END IF;
    RETURN NEW;
END;
$$ LANGUAGE PLPGSQL;

CREATE OR REPLACE TRIGGER TRG_TELEFONE_FUNCIONARIO
BEFORE INSERT OR UPDATE ON FUNCIONARIO
FOR EACH ROW
EXECUTE FUNCTION VALIDA_TELEFONE_FUNCIONARIO();

-- ==================================================
-- ========= COMPOSIÇÃO DE PRODUTOS =================
-- ==================================================
DROP FUNCTION adicionar_composicao_produto(integer,integer,integer);


CREATE OR REPLACE FUNCTION ADICIONAR_COMPOSICAO_PRODUTO(
    PROD1 INT,
    PROD2 INT,
    QUANTIDADE INT
) RETURNS TEXT AS $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM PRODUTO WHERE ID_PRODUTO = PROD1) THEN
            RETURN 'ERRO: PRODUTO PRINCIPAL NÃO ENCONTRADO.';
        END IF;

        IF NOT EXISTS (SELECT 1 FROM PRODUTO WHERE ID_PRODUTO = PROD2) THEN
            RETURN 'ERRO: PRODUTO COMPONENTE NÃO ENCONTRADO.';
        END IF;

        INSERT INTO COMPOSICAO_PRONTA(ID_PROD_COMP1, ID_PROD_COMP2, QUANT)
        VALUES (PROD1, PROD2, QUANTIDADE);

        RETURN 'SUCESSO: COMPOSIÇÃO REGISTRADA.';
    EXCEPTION
        WHEN INSUFFICIENT_PRIVILEGE THEN
            RETURN 'ERRO: SEM PERMISSÃO PARA CRIAR COMPOSIÇÕES.';
        WHEN OTHERS THEN
            RAISE LOG 'ERRO AO CRIAR COMPOSIÇÃO (% + %): %', PROD1, PROD2, SQLERRM;
            RETURN 'ERRO: FALHA AO REGISTRAR COMPOSIÇÃO.';
    END;
END;
$$ LANGUAGE PLPGSQL;

-- --------------------------------------------------

CREATE OR REPLACE FUNCTION VERIFICAR_ESTOQUE_COMPOSICAO_RECURSIVO(
    P_ID_PRODUTO INT,
    P_QUANTIDADE INT
) RETURNS BOOLEAN AS $$
DECLARE
    COMPONENTE RECORD;
    TEM_ESTOQUE BOOLEAN;
    COMPONENTE_EH_COMPOSTO BOOLEAN;
    QUANT_NECESSARIA INT;
BEGIN
    IF NOT EXISTS (SELECT 1 FROM COMPOSICAO_PRONTA WHERE ID_PROD_COMP1 = P_ID_PRODUTO) THEN
        RETURN (SELECT ESTOQUE >= P_QUANTIDADE FROM PRODUTO WHERE ID_PRODUTO = P_ID_PRODUTO);
    END IF;

    FOR COMPONENTE IN
        SELECT CP.ID_PROD_COMP2, CP.QUANT, CP.PERDA
        FROM COMPOSICAO_PRONTA CP
        WHERE CP.ID_PROD_COMP1 = P_ID_PRODUTO
    LOOP
        QUANT_NECESSARIA := CEIL(COMPONENTE.QUANT * P_QUANTIDADE * (1 + COMPONENTE.PERDA / 100.0));

        SELECT EXISTS (
            SELECT 1 FROM COMPOSICAO_PRONTA
            WHERE ID_PROD_COMP1 = COMPONENTE.ID_PROD_COMP2
        ) INTO COMPONENTE_EH_COMPOSTO;

        IF COMPONENTE_EH_COMPOSTO THEN
            TEM_ESTOQUE := VERIFICAR_ESTOQUE_COMPOSICAO_RECURSIVO(
                COMPONENTE.ID_PROD_COMP2,
                QUANT_NECESSARIA
            );
        ELSE
            TEM_ESTOQUE := (SELECT ESTOQUE >= QUANT_NECESSARIA FROM PRODUTO WHERE ID_PRODUTO = COMPONENTE.ID_PROD_COMP2);
        END IF;

        IF NOT TEM_ESTOQUE THEN
            RETURN FALSE;
        END IF;
    END LOOP;

    RETURN TRUE;
END;
$$ LANGUAGE PLPGSQL;

-- --------------------------------------------------
DROP FUNCTION montar_produto_composto(integer,integer);

CREATE OR REPLACE FUNCTION MONTAR_PRODUTO_COMPOSTO(
    P_ID_PRODUTO INT,
    P_QUANTIDADE INT
) RETURNS TEXT AS $$
DECLARE
    COMPONENTE RECORD;
    CUSTO_TOTAL DECIMAL(10,2) := 0;
    PRECO_SUGERIDO DECIMAL(10,2);
    MARGEM DECIMAL(5,2) := 1.3;
    QUANT_NECESSARIA INT;
BEGIN
    BEGIN
        IF NOT VERIFICAR_ESTOQUE_COMPOSICAO_RECURSIVO(P_ID_PRODUTO, P_QUANTIDADE) THEN
            RETURN 'ERRO: ESTOQUE INSUFICIENTE PARA MONTAGEM.';
        END IF;

        FOR COMPONENTE IN
            SELECT CP.ID_PROD_COMP2, CP.QUANT, CP.PERDA, P.PRECO
            FROM COMPOSICAO_PRONTA CP
            JOIN PRODUTO P ON CP.ID_PROD_COMP2 = P.ID_PRODUTO
            WHERE CP.ID_PROD_COMP1 = P_ID_PRODUTO
        LOOP
            QUANT_NECESSARIA := CEIL(COMPONENTE.QUANT * P_QUANTIDADE * (1 + COMPONENTE.PERDA / 100.0));

            UPDATE PRODUTO
            SET ESTOQUE = ESTOQUE - QUANT_NECESSARIA
            WHERE ID_PRODUTO = COMPONENTE.ID_PROD_COMP2;

            CUSTO_TOTAL := CUSTO_TOTAL + (QUANT_NECESSARIA * COMPONENTE.PRECO);
        END LOOP;

        UPDATE PRODUTO
        SET ESTOQUE = ESTOQUE + P_QUANTIDADE
        WHERE ID_PRODUTO = P_ID_PRODUTO;

        PRECO_SUGERIDO := (CUSTO_TOTAL / P_QUANTIDADE) * MARGEM;

        UPDATE PRODUTO
        SET PRECO = PRECO_SUGERIDO
        WHERE ID_PRODUTO = P_ID_PRODUTO;

        RETURN 'SUCESSO: PRODUTO MONTADO. PREÇO SUGERIDO: R$ ' || PRECO_SUGERIDO;
    EXCEPTION
        WHEN INSUFFICIENT_PRIVILEGE THEN
            RETURN 'ERRO: SEM PERMISSÃO PARA MONTAR PRODUTOS.';
        WHEN OTHERS THEN
            RAISE LOG 'ERRO AO MONTAR PRODUTO (ID: %): %', P_ID_PRODUTO, SQLERRM;
            RETURN 'ERRO: FALHA NA MONTAGEM DO PRODUTO.';
    END;
END;
$$ LANGUAGE PLPGSQL;

-- --------------------------------------------------

CREATE OR REPLACE FUNCTION PROCESSAR_PEDIDO_COMPOSTO()
RETURNS TRIGGER AS $$
DECLARE
    TEMPO_MONTAGEM INT := 0;
    EH_PRODUTO_COMPOSTO BOOLEAN;
BEGIN
    SELECT EXISTS (
        SELECT 1 FROM COMPOSICAO_PRONTA
        WHERE ID_PROD_COMP1 = NEW.ID_PRODUTO
    ) INTO EH_PRODUTO_COMPOSTO;

    IF EH_PRODUTO_COMPOSTO THEN
        SELECT SUM(CP.TEMPO_MONTAGEM) INTO TEMPO_MONTAGEM
        FROM COMPOSICAO_PRONTA CP
        WHERE CP.ID_PROD_COMP1 = NEW.ID_PRODUTO;

        UPDATE PEDIDO
        SET OBSERVACAO = CONCAT('NECESSITA MONTAGEM - TEMPO ESTIMADO: ', TEMPO_MONTAGEM, 'MIN')
        WHERE ID_PEDIDO = NEW.ID_PEDIDO;

        IF NOT VERIFICAR_ESTOQUE_COMPOSICAO_RECURSIVO(NEW.ID_PRODUTO, NEW.QUANT) THEN
            PERFORM MONTAR_PRODUTO_COMPOSTO(NEW.ID_PRODUTO, NEW.QUANT);
        END IF;
    END IF;

    RETURN NEW;
END;
$$ LANGUAGE PLPGSQL;

CREATE OR REPLACE TRIGGER TRG_PROCESSAR_PEDIDO_COMPOSTO
BEFORE INSERT ON ITEM_PEDIDO
FOR EACH ROW
EXECUTE FUNCTION PROCESSAR_PEDIDO_COMPOSTO();

-- ==================================================
-- ==================== RELATÓRIOS ==================
-- ==================================================

CREATE OR REPLACE FUNCTION PRODUTOS_BAIXO_ESTOQUE(LIMITE INT)
RETURNS TABLE(ID_PRODUTO INT, NOME VARCHAR, ESTOQUE INT, PRECO DECIMAL) AS $$
BEGIN
    RETURN QUERY
    SELECT P.ID_PRODUTO, P.NOME, P.ESTOQUE, P.PRECO
    FROM PRODUTO P
    WHERE P.ESTOQUE < LIMITE AND P.ATIVO = TRUE
    ORDER BY P.ESTOQUE;
END;
$$ LANGUAGE PLPGSQL;

-- --------------------------------------------------

CREATE OR REPLACE FUNCTION PRODUTOS_MAIS_VENDIDOS(LIMITE INT)
RETURNS TABLE(ID_PRODUTO INT, NOME VARCHAR, QUANTIDADE BIGINT, TOTAL DECIMAL) AS $$
BEGIN
    RETURN QUERY
    SELECT P.ID_PRODUTO, P.NOME, SUM(IP.QUANT), SUM(IP.QUANT * IP.VALOR_UNITARIO)
    FROM PRODUTO P
    JOIN ITEM_PEDIDO IP ON P.ID_PRODUTO = IP.ID_PRODUTO
    JOIN PEDIDO PE ON IP.ID_PEDIDO = PE.ID_PEDIDO
    WHERE P.ATIVO = TRUE AND IP.ATIVO = TRUE AND PE.ATIVO = TRUE
    GROUP BY P.ID_PRODUTO, P.NOME
    ORDER BY SUM(IP.QUANT) DESC
    LIMIT LIMITE;
END;
$$ LANGUAGE PLPGSQL;

-- --------------------------------------------------

CREATE OR REPLACE FUNCTION VENDAS_POR_FUNCIONARIO()
RETURNS TABLE(
    ID_FUNCIONARIO INT,
    NOME VARCHAR,
    CARGO VARCHAR,
    TOTAL_VENDAS DECIMAL,
    QTD_PEDIDOS BIGINT
) AS $$
BEGIN
    RETURN QUERY
    SELECT F.ID_FUNCIONARIO, F.NOME, F.CARGO,
           COALESCE(SUM(P.TOTAL), 0)::DECIMAL AS TOTAL_VENDAS,
           COUNT(P.ID_PEDIDO)::BIGINT AS QTD_PEDIDOS
    FROM FUNCIONARIO F
    LEFT JOIN PEDIDO P ON F.ID_FUNCIONARIO = P.ID_FUNCIONARIO
    WHERE F.ATIVO = TRUE AND (P.ID_PEDIDO IS NULL OR P.ATIVO = TRUE)
    GROUP BY F.ID_FUNCIONARIO, F.NOME, F.CARGO
    ORDER BY TOTAL_VENDAS DESC;
END;
$$ LANGUAGE PLPGSQL;
