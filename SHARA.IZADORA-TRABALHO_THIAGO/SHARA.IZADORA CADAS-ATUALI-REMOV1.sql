-- ==================================================
--   ============= FUNÇÕES DE CADASTRO ===============
-- ==================================================

CREATE OR REPLACE FUNCTION CADASTRAR_CLIENTE(
    P_ID INT,
    P_NOME VARCHAR,
    P_ENDERECO VARCHAR,
    P_TELEFONE VARCHAR,
    P_EMAIL VARCHAR
) RETURNS TEXT AS $$
BEGIN
    BEGIN
        IF EXISTS (SELECT 1 FROM CLIENTE WHERE ID_CLIENTE = P_ID) THEN
            RETURN 'ERRO: ID DE CLIENTE JÁ EXISTE.';
        END IF;

        IF P_EMAIL !~ '^[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Za-z]{2,}$' THEN
            RETURN 'ERRO: FORMATO DE EMAIL INVÁLIDO.';
        END IF;

        INSERT INTO CLIENTE (ID_CLIENTE, NOME, ENDERECO, TELEFONE, EMAIL, ATIVO)
        VALUES (P_ID, P_NOME, P_ENDERECO, P_TELEFONE, P_EMAIL, TRUE);

        RETURN 'CLIENTE CADASTRADO COM SUCESSO. ID: ' || P_ID;

    EXCEPTION 
        WHEN INSUFFICIENT_PRIVILEGE THEN
            RETURN 'ERRO: SEU PERFIL NÃO TEM PERMISSÃO PARA CADASTRAR CLIENTES.';
        WHEN UNIQUE_VIOLATION THEN
            RETURN 'ERRO: JÁ EXISTE UM CLIENTE COM ESTE ID OU INFORMAÇÕES ÚNICAS.';
        WHEN NOT_NULL_VIOLATION THEN
            RETURN 'ERRO: TODOS OS CAMPOS OBRIGATÓRIOS DEVEM SER PREENCHIDOS.';
        WHEN OTHERS THEN
            RAISE LOG 'ERRO AO CADASTRAR CLIENTE: %', SQLERRM;
            RETURN 'ERRO: NÃO FOI POSSÍVEL COMPLETAR O CADASTRO.';
    END;
END;
$$ LANGUAGE PLPGSQL;

-- --------------------------------------------------

CREATE OR REPLACE FUNCTION CADASTRAR_FUNCIONARIO(
    P_ID INT,
    P_NOME VARCHAR,
    P_TELEFONE VARCHAR,
    P_EMAIL VARCHAR,
    P_CARGO VARCHAR
) RETURNS TEXT AS $$
DECLARE
    v_telefone_limpo VARCHAR;
BEGIN
    BEGIN
        v_telefone_limpo := regexp_replace(P_TELEFONE, '[^0-9]', '', 'g');

        IF EXISTS (SELECT 1 FROM FUNCIONARIO WHERE ID_FUNCIONARIO = P_ID) THEN
            RETURN 'ERRO: ID ' || P_ID || ' JÁ ESTÁ CADASTRADO PARA OUTRO FUNCIONÁRIO';
        END IF;

        IF P_EMAIL !~ '^[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Za-z]{2,}$' THEN
            RETURN 'ERRO: FORMATO DE E-MAIL INVÁLIDO';
        END IF;

        IF v_telefone_limpo !~ '^[0-9]{10,11}$' THEN
            RETURN 'ERRO: TELEFONE DEVE CONTER 10 OU 11 DÍGITOS NUMÉRICOS (APÓS LIMPEZA)';
        END IF;

        INSERT INTO FUNCIONARIO (ID_FUNCIONARIO, NOME, TELEFONE, EMAIL, CARGO, ATIVO)
        VALUES (P_ID, P_NOME, v_telefone_limpo, P_EMAIL, P_CARGO, TRUE);

        RETURN 'SUCESSO: FUNCIONÁRIO ' || P_NOME || ' CADASTRADO COM ID ' || P_ID;

    EXCEPTION
        WHEN UNIQUE_VIOLATION THEN
            RETURN 'ERRO: FUNCIONÁRIO COM ID OU DADOS JÁ EXISTENTE.';
        WHEN OTHERS THEN
            RAISE LOG 'ERRO AO CADASTRAR FUNCIONÁRIO (ID: %): %', P_ID, SQLERRM;
            RETURN 'ERRO: FALHA AO CADASTRAR FUNCIONÁRIO. Verifique os logs.';
    END;
END;
$$ LANGUAGE PLPGSQL;
-- --------------------------------------------------

CREATE OR REPLACE FUNCTION CADASTRAR_FORNECEDOR(
    P_ID INT,
    P_NOME VARCHAR,
    P_TELEFONE VARCHAR,
    P_EMAIL VARCHAR
) RETURNS TEXT AS $$
BEGIN
    BEGIN
        IF EXISTS (SELECT 1 FROM FORNECEDOR WHERE ID_FORNECEDOR = P_ID) THEN
            RETURN 'ERRO: FORNECEDOR COM ESTE ID JÁ EXISTE.';
        END IF;

        IF P_EMAIL !~ '^[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Za-z]{2,}$' THEN
            RETURN 'ERRO: FORMATO DE E-MAIL INVÁLIDO.';
        END IF;

        INSERT INTO FORNECEDOR (ID_FORNECEDOR, NOME, TELEFONE, EMAIL, ATIVO)
        VALUES (P_ID, P_NOME, P_TELEFONE, P_EMAIL, TRUE);

        RETURN 'SUCESSO: FORNECEDOR ' || P_NOME || ' CADASTRADO COM ID ' || P_ID;

    EXCEPTION
        WHEN UNIQUE_VIOLATION THEN
            RETURN 'ERRO: FORNECEDOR JÁ EXISTENTE.';
        WHEN INSUFFICIENT_PRIVILEGE THEN
            RETURN 'ERRO: SEU PERFIL NÃO TEM PERMISSÃO PARA CADASTRAR FORNECEDORES.';
        WHEN OTHERS THEN
            RAISE LOG 'ERRO AO CADASTRAR FORNECEDOR (ID: %): %', P_ID, SQLERRM;
            RETURN 'ERRO: FALHA AO CADASTRAR FORNECEDOR.';
    END;
END;
$$ LANGUAGE PLPGSQL;
-- --------------------------------------------------
CREATE OR REPLACE FUNCTION CADASTRAR_PRODUTO(
    P_ID INT,
    P_ESTOQUE INT,
    P_NOME VARCHAR,
    P_PRECO DECIMAL,
    P_TIPO VARCHAR
) RETURNS TEXT AS $$
BEGIN
    BEGIN
        IF EXISTS (SELECT 1 FROM PRODUTO WHERE ID_PRODUTO = P_ID) THEN
            RETURN 'ERRO: PRODUTO COM ID ' || P_ID || ' JÁ EXISTE.';
        END IF;

        IF P_ESTOQUE < 0 THEN
            RETURN 'ERRO: ESTOQUE NÃO PODE SER NEGATIVO.';
        END IF;

        IF P_PRECO < 0 THEN
            RETURN 'ERRO: PREÇO NÃO PODE SER NEGATIVO.';
        END IF;

        INSERT INTO PRODUTO (ID_PRODUTO, ESTOQUE, NOME, PRECO, TIPO, ATIVO)
        VALUES (P_ID, P_ESTOQUE, P_NOME, P_PRECO, P_TIPO, TRUE);

        RETURN 'PRODUTO CADASTRADO COM SUCESSO. ID: ' || P_ID;

    EXCEPTION
        WHEN CHECK_VIOLATION THEN
            RETURN 'ERRO: VALORES INVÁLIDOS (ESTOQUE, PREÇO, ETC).';
        WHEN UNIQUE_VIOLATION THEN
            RETURN 'ERRO: PRODUTO COM ID OU DADOS JÁ EXISTENTE.';
        WHEN INSUFFICIENT_PRIVILEGE THEN
            RETURN 'ERRO: SEU PERFIL NÃO TEM PERMISSÃO PARA CADASTRAR PRODUTOS.';
        WHEN OTHERS THEN
            RAISE LOG 'ERRO AO CADASTRAR PRODUTO: %', SQLERRM;
            RETURN 'ERRO: FALHA NO CADASTRO DO PRODUTO.';
    END;
END;
$$ LANGUAGE PLPGSQL;

---------------------------------------------------------
CREATE OR REPLACE FUNCTION CADASTRAR_COMPOSICAO(
    P_ID_PROD_COMP1 INT,
    P_ID_PROD_COMP2 INT,
    P_QUANTIDADE INT,
    P_PERDA DECIMAL DEFAULT 0,
    P_TEMPO_MONTAGEM INT DEFAULT 15
) RETURNS TEXT AS $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM PRODUTO WHERE ID_PRODUTO = P_ID_PROD_COMP1 AND ATIVO = TRUE) THEN
            RETURN 'ERRO: PRODUTO PRINCIPAL NÃO ENCONTRADO OU INATIVO.';
        END IF;

        IF NOT EXISTS (SELECT 1 FROM PRODUTO WHERE ID_PRODUTO = P_ID_PROD_COMP2 AND ATIVO = TRUE) THEN
            RETURN 'ERRO: PRODUTO COMPONENTE NÃO ENCONTRADO OU INATIVO.';
        END IF;

        IF EXISTS (
            SELECT 1 FROM COMPOSICAO_PRONTA 
            WHERE ID_PROD_COMP1 = P_ID_PROD_COMP1 
            AND ID_PROD_COMP2 = P_ID_PROD_COMP2
            AND ATIVO = TRUE
        ) THEN
            RETURN 'ERRO: ESTA COMPOSIÇÃO JÁ EXISTE.';
        END IF;

        INSERT INTO COMPOSICAO_PRONTA (
            ID_PROD_COMP1, ID_PROD_COMP2, QUANT, PERDA, TEMPO_MONTAGEM, ATIVO
        ) VALUES (
            P_ID_PROD_COMP1, P_ID_PROD_COMP2, P_QUANTIDADE, P_PERDA, P_TEMPO_MONTAGEM, TRUE
        );

        RETURN 'SUCESSO: COMPOSIÇÃO CADASTRADA.';

    EXCEPTION
        WHEN OTHERS THEN
            RETURN 'ERRO: FALHA AO CADASTRAR COMPOSIÇÃO. ' || SQLERRM;
    END;
END;
$$ LANGUAGE PLPGSQL;
-- ==================================================
--   ========== FUNÇÕES DE ATUALIZAÇÃO ================
-- ==================================================

CREATE OR REPLACE FUNCTION ATUALIZAR_ESTOQUE(
    P_ID INT,
    P_QUANTIDADE INT
) RETURNS TEXT AS $$
BEGIN
    -- Verifica se o produto existe e está ativo
    IF NOT EXISTS (SELECT 1 FROM PRODUTO WHERE ID_PRODUTO = P_ID AND ATIVO = TRUE) THEN
        RETURN 'ERRO: PRODUTO NÃO ENCONTRADO OU INATIVO.';
    END IF;

    -- Validação de quantidade
    IF P_QUANTIDADE < 0 THEN
        RETURN 'ERRO: QUANTIDADE NÃO PODE SER NEGATIVA.';
    END IF;

    -- Atualiza o estoque
    UPDATE PRODUTO SET ESTOQUE = P_QUANTIDADE WHERE ID_PRODUTO = P_ID;

    RETURN 'SUCESSO: ESTOQUE ATUALIZADO PARA ' || P_QUANTIDADE || ' UNIDADES.';
    
EXCEPTION
    WHEN OTHERS THEN
        RAISE LOG 'ERRO AO ATUALIZAR ESTOQUE (PRODUTO: %): %', P_ID, SQLERRM;
        RETURN 'ERRO: FALHA NA ATUALIZAÇÃO DO ESTOQUE.';
END;
$$ LANGUAGE PLPGSQL;

-- --------------------------------------------------
CREATE OR REPLACE FUNCTION ATUALIZAR_ESTOQUE_COMPRA() RETURNS TRIGGER AS $$
BEGIN
    IF (SELECT ATIVO FROM PRODUTO WHERE ID_PRODUTO = NEW.ID_PRODUTO) = TRUE THEN
        UPDATE PRODUTO
        SET ESTOQUE = ESTOQUE + NEW.QUANT
        WHERE ID_PRODUTO = NEW.ID_PRODUTO;
    END IF;
    RETURN NEW;
END;
$$ LANGUAGE PLPGSQL;

CREATE TRIGGER TRG_ESTOQUE_COMPRA
AFTER INSERT ON ITEM_COMPRA
FOR EACH ROW
EXECUTE FUNCTION ATUALIZAR_ESTOQUE_COMPRA();
-- --------------------------------------------------

CREATE OR REPLACE FUNCTION ATUALIZAR_ESTOQUE_PEDIDO() RETURNS TRIGGER AS $$
DECLARE
    V_ESTOQUE_ATUAL INT;
BEGIN
    -- Validações
    IF (SELECT ATIVO FROM PEDIDO WHERE ID_PEDIDO = NEW.ID_PEDIDO) = FALSE THEN
        RAISE EXCEPTION 'PEDIDO INATIVO: %', NEW.ID_PEDIDO;
    END IF;

    IF (SELECT ATIVO FROM PRODUTO WHERE ID_PRODUTO = NEW.ID_PRODUTO) = FALSE THEN
        RAISE EXCEPTION 'PRODUTO INATIVO: %', NEW.ID_PRODUTO;
    END IF;

    SELECT ESTOQUE INTO V_ESTOQUE_ATUAL FROM PRODUTO WHERE ID_PRODUTO = NEW.ID_PRODUTO;
    
    IF V_ESTOQUE_ATUAL < NEW.QUANT THEN
        RAISE EXCEPTION 'ESTOQUE INSUFICIENTE PARA O PRODUTO %. Disponível: %, Solicitado: %',
            NEW.ID_PRODUTO, V_ESTOQUE_ATUAL, NEW.QUANT;
    END IF;

    UPDATE PRODUTO
    SET ESTOQUE = ESTOQUE - NEW.QUANT
    WHERE ID_PRODUTO = NEW.ID_PRODUTO;

    RETURN NEW;
END;
$$ LANGUAGE PLPGSQL;

CREATE TRIGGER TRG_ESTOQUE_PEDIDO
BEFORE INSERT ON ITEM_PEDIDO
FOR EACH ROW
EXECUTE FUNCTION ATUALIZAR_ESTOQUE_PEDIDO();


-- ==================================================
--   =========== FUNÇÕES DE REMOÇÃO ===================
-- ==================================================
CREATE OR REPLACE FUNCTION REMOVER_CLIENTE(P_ID INT) RETURNS TEXT AS $$
BEGIN
    BEGIN
        
        IF NOT EXISTS (SELECT 1 FROM CLIENTE WHERE ID_CLIENTE = P_ID) THEN
            RETURN 'ERRO: CLIENTE NÃO ENCONTRADO.';
        END IF;

       
        IF EXISTS (SELECT 1 FROM PEDIDO WHERE ID_CLIENTE = P_ID AND ATIVO = TRUE) THEN
            RETURN 'ERRO: CLIENTE POSSUI PEDIDOS ATIVOS ASSOCIADOS.';
        END IF;

        
        UPDATE CLIENTE SET ATIVO = FALSE WHERE ID_CLIENTE = P_ID;

        RETURN 'SUCESSO: CLIENTE MARCADO COMO INATIVO. ID: ' || P_ID;

    EXCEPTION
        WHEN INSUFFICIENT_PRIVILEGE THEN
            RETURN 'ERRO: SEU PERFIL NÃO TEM PERMISSÃO PARA REMOVER CLIENTES.';
        WHEN OTHERS THEN
            RAISE LOG 'ERRO AO REMOVER CLIENTE (ID: %): %', P_ID, SQLERRM;
            RETURN 'ERRO: FALHA AO REMOVER CLIENTE.';
    END;
END;
$$ LANGUAGE PLPGSQL;

-- --------------------------------------------------

CREATE OR REPLACE FUNCTION REMOVER_PRODUTO(P_ID INT) RETURNS TEXT AS $$
BEGIN
   
    IF NOT EXISTS (SELECT 1 FROM PRODUTO WHERE ID_PRODUTO = P_ID) THEN
        RETURN 'ERRO: PRODUTO NÃO ENCONTRADO.';
    END IF;

    
    IF EXISTS (SELECT 1 FROM ITEM_PEDIDO IP JOIN PEDIDO P ON IP.ID_PEDIDO = P.ID_PEDIDO
               WHERE IP.ID_PRODUTO = P_ID AND P.ATIVO = TRUE) THEN
        RETURN 'ERRO: PRODUTO ESTÁ EM PEDIDOS ATIVOS.';
    END IF;

    
    IF EXISTS (SELECT 1 FROM COMPOSICAO_PRONTA
               WHERE (ID_PROD_COMP1 = P_ID OR ID_PROD_COMP2 = P_ID) AND ATIVO = TRUE) THEN
        RETURN 'ERRO: PRODUTO ESTÁ EM COMPOSIÇÕES ATIVAS.';
    END IF;

    
    UPDATE PRODUTO SET ATIVO = FALSE WHERE ID_PRODUTO = P_ID;

    RETURN 'PRODUTO MARCADO COMO INATIVO COM SUCESSO. ID: ' || P_ID;

EXCEPTION
    WHEN OTHERS THEN
        RETURN 'ERRO AO REMOVER PRODUTO: ' || SQLERRM;
END;
$$ LANGUAGE PLPGSQL;

-------------------------------------------------------------
CREATE OR REPLACE FUNCTION REMOVER_PEDIDO(P_ID_PEDIDO INT) RETURNS TEXT AS $$
BEGIN
    BEGIN
        
        UPDATE ITEM_PEDIDO SET ATIVO = FALSE WHERE ID_PEDIDO = P_ID_PEDIDO;

       
        UPDATE PEDIDO SET ATIVO = FALSE WHERE ID_PEDIDO = P_ID_PEDIDO;

        RETURN 'PEDIDOS E ITENS MARCADOS COMO INATIVOS';

    EXCEPTION
        WHEN OTHERS THEN
            RETURN 'ERRO AO REMOVER PEDIDO: ' || SQLERRM;
    END;
END;
$$ LANGUAGE PLPGSQL;

-- ---------------------------------------------------------------------

CREATE OR REPLACE FUNCTION REMOVER_COMPRA(P_ID_COMPRA INT) RETURNS TEXT AS $$
BEGIN
    BEGIN
        -- Primeiro desativar itens da compra
        UPDATE ITEM_COMPRA SET ATIVO = FALSE WHERE ID_COMPRA = P_ID_COMPRA;

        -- Depois desativar a compra
        UPDATE COMPRA SET ATIVO = FALSE WHERE ID_COMPRA = P_ID_COMPRA;

        RETURN 'COMPRA E ITENS MARCADOS COMO INATIVOS';

    EXCEPTION
        WHEN OTHERS THEN
            RETURN 'ERRO AO REMOVER COMPRA: ' || SQLERRM;
    END;
END;
$$ LANGUAGE PLPGSQL;

----------------------------------------------
-- ==================================================
--   ========== FUNÇÕES DE REGISTRO ===================
-- ==================================================
CREATE OR REPLACE FUNCTION REGISTRAR_PEDIDO(
    P_ID_PEDIDO INT,
    P_ID_CLIENTE INT,
    P_TELEFONE VARCHAR,
    P_ID_FUNCIONARIO INT,
    P_ITEMS JSONB
) RETURNS TEXT AS $$
DECLARE
    V_TOTAL_PEDIDO DECIMAL(10,2) := 0;
    V_ITEM JSONB;
    V_QUANTIDADE INT;
    V_PRECO DECIMAL(10,2);
    V_MENSAGEM TEXT;
    V_ID_PRODUTO INT;
BEGIN
    IF NOT EXISTS (SELECT 1 FROM CLIENTE WHERE ID_CLIENTE = P_ID_CLIENTE AND ATIVO = TRUE) THEN
        RETURN 'ERRO: CLIENTE INEXISTENTE OU INATIVO.';
    END IF;

    IF NOT EXISTS (SELECT 1 FROM FUNCIONARIO WHERE ID_FUNCIONARIO = P_ID_FUNCIONARIO) THEN
        RETURN 'ERRO: FUNCIONÁRIO NÃO ENCONTRADO.';
    END IF;

    FOR V_ITEM IN SELECT * FROM JSONB_ARRAY_ELEMENTS(P_ITEMS)
    LOOP
        V_ID_PRODUTO := (V_ITEM->>'ID_PRODUTO')::INT;
        V_QUANTIDADE := (V_ITEM->>'QUANTIDADE')::INT;

        IF NOT EXISTS (SELECT 1 FROM PRODUTO WHERE ID_PRODUTO = V_ID_PRODUTO AND ATIVO = TRUE) THEN
            RETURN 'ERRO: PRODUTO ' || V_ID_PRODUTO || ' INEXISTENTE OU INATIVO.';
        END IF;

        IF EXISTS (SELECT 1 FROM COMPOSICAO_PRONTA WHERE ID_PROD_COMP1 = V_ID_PRODUTO AND ATIVO = TRUE) THEN
            IF NOT VERIFICAR_ESTOQUE_COMPOSICAO_RECURSIVO(V_ID_PRODUTO, V_QUANTIDADE) THEN
                V_MENSAGEM := MONTAR_PRODUTO_COMPOSTO(V_ID_PRODUTO, V_QUANTIDADE);
                IF V_MENSAGEM NOT LIKE 'SUCESSO%' THEN
                    RETURN 'ERRO: NÃO FOI POSSÍVEL MONTAR O PRODUTO COMPOSTO ' || V_ID_PRODUTO || '. ' || V_MENSAGEM;
                END IF;
            END IF;
        ELSE
            IF (SELECT ESTOQUE FROM PRODUTO WHERE ID_PRODUTO = V_ID_PRODUTO) < V_QUANTIDADE THEN
                RETURN 'ERRO: ESTOQUE INSUFICIENTE PARA O PRODUTO ' || V_ID_PRODUTO;
            END IF;
        END IF;

        SELECT PRECO INTO V_PRECO FROM PRODUTO WHERE ID_PRODUTO = V_ID_PRODUTO;
        V_TOTAL_PEDIDO := V_TOTAL_PEDIDO + (V_PRECO * V_QUANTIDADE);
    END LOOP;

    INSERT INTO PEDIDO (ID_PEDIDO, ID_CLIENTE, TELEFONE, TOTAL, ID_FUNCIONARIO)
    VALUES (P_ID_PEDIDO, P_ID_CLIENTE, P_TELEFONE, V_TOTAL_PEDIDO, P_ID_FUNCIONARIO);

    FOR V_ITEM IN SELECT * FROM JSONB_ARRAY_ELEMENTS(P_ITEMS)
    LOOP
        INSERT INTO ITEM_PEDIDO (ID_PEDIDO, ID_PRODUTO, QUANT)
        VALUES (
            P_ID_PEDIDO,
            (V_ITEM->>'ID_PRODUTO')::INT,
            (V_ITEM->>'QUANTIDADE')::INT
        );
    END LOOP;

    RETURN 'PEDIDO REGISTRADO COM SUCESSO. TOTAL: R$ ' || V_TOTAL_PEDIDO;

EXCEPTION
    WHEN INSUFFICIENT_PRIVILEGE THEN
        RETURN 'ERRO: PERMISSÃO NEGADA PARA REGISTRAR PEDIDOS.';
    WHEN UNIQUE_VIOLATION THEN
        RETURN 'ERRO: ID DE PEDIDO JÁ EXISTENTE.';
    WHEN FOREIGN_KEY_VIOLATION THEN
        RETURN 'ERRO: CHAVES ESTRANGEIRAS INVÁLIDAS.';
    WHEN OTHERS THEN
        RETURN 'ERRO: FALHA INTERNA AO REGISTRAR PEDIDO.';
END;
$$ LANGUAGE PLPGSQL;

-- --------------------------------------------------
CREATE OR REPLACE FUNCTION REGISTRAR_COMPRA(
    P_ID_COMPRA INT,
    P_ID_FORNECEDOR INT,
    P_DATA DATE,
    P_ID_FUNCIONARIO INT,
    P_ID_PRODUTO1 INT,
    P_QUANT1 INT,
    P_VALOR1 DECIMAL,
    P_ID_PRODUTO2 INT DEFAULT NULL,
    P_QUANT2 INT DEFAULT NULL,
    P_VALOR2 DECIMAL DEFAULT NULL
) RETURNS TEXT AS $$
BEGIN
    IF NOT EXISTS (SELECT 1 FROM FORNECEDOR WHERE ID_FORNECEDOR = P_ID_FORNECEDOR) THEN
        RETURN 'ERRO: FORNECEDOR NÃO ENCONTRADO.';
    END IF;

    IF NOT EXISTS (SELECT 1 FROM FUNCIONARIO WHERE ID_FUNCIONARIO = P_ID_FUNCIONARIO) THEN
        RETURN 'ERRO: FUNCIONÁRIO NÃO ENCONTRADO.';
    END IF;

    IF NOT EXISTS (SELECT 1 FROM PRODUTO WHERE ID_PRODUTO = P_ID_PRODUTO1) THEN
        RETURN 'ERRO: PRODUTO PRINCIPAL NÃO ENCONTRADO.';
    END IF;

    IF P_ID_PRODUTO2 IS NOT NULL THEN
        IF NOT EXISTS (SELECT 1 FROM PRODUTO WHERE ID_PRODUTO = P_ID_PRODUTO2) THEN
            RETURN 'ERRO: PRODUTO ADICIONAL NÃO ENCONTRADO.';
        END IF;
    END IF;

    INSERT INTO COMPRA (ID_COMPRA, ID_FORNECEDOR, DATA, TOTAL, ID_FUNCIONARIO)
    VALUES (P_ID_COMPRA, P_ID_FORNECEDOR, P_DATA, 0, P_ID_FUNCIONARIO);

    INSERT INTO ITEM_COMPRA(ID_COMPRA, ID_PRODUTO, QUANT, VALOR_UNITARIO)
    VALUES (P_ID_COMPRA, P_ID_PRODUTO1, P_QUANT1, P_VALOR1);

    IF P_ID_PRODUTO2 IS NOT NULL THEN
        INSERT INTO ITEM_COMPRA(ID_COMPRA, ID_PRODUTO, QUANT, VALOR_UNITARIO)
        VALUES (P_ID_COMPRA, P_ID_PRODUTO2, P_QUANT2, P_VALOR2);
    END IF;

    RETURN 'SUCESSO: COMPRA REGISTRADA COM ID ' || P_ID_COMPRA;

EXCEPTION
    WHEN INSUFFICIENT_PRIVILEGE THEN
        RETURN 'ERRO: SEM PERMISSÃO PARA REGISTRAR COMPRA.';
    WHEN OTHERS THEN
        RAISE LOG 'ERRO AO REGISTRAR COMPRA (ID: %): %', P_ID_COMPRA, SQLERRM;
        RETURN 'ERRO: FALHA INTERNA AO REGISTRAR COMPRA.';
END;
$$ LANGUAGE PLPGSQL;

-- ==================================================
--   ==================================================
-- ==================================================
